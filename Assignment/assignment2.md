## 필수 구현 과제

1. 강좌 1부터 4까지 처럼 작동하는 Memorize 게임을 만드세요. 모든 코드를 직접 작성하고 복사/붙여넣기는 하면 안됩니다.

2. 과제1 에서부터 시작하는 거라면, 테마 선택 버튼과 게임 제목(선택 사항)을 제거하고 시작하세요.

3. Model에 공식적으로 테마를 추가세요. 테마는 이름, 이모지 세트, 몇개의 카드를 보여줄 거인지, 카드를 그리는데 사용할 적절한 색상을 포함합니다.

4. 게임에서 하나 이상의 테마는 테마에서 가능한 이모지의 숫자보다 적은 수의 카드 쌍을 보여주어야 합니다.

5. 테마에서 보여줄 이모지 쌍의 수가 해당 테마에서 사용할 수 있는 이모지의 개수보다 적은 경우, 테마의 처음 몇개 이모지만 사용해서는 안됩니다. 다시 말해서, 게임에서 보여줄 수 없는 "죽은 이모지"가 있어서는 안됩니다.

6. 한 쌍의 카드만이 같은 이모지를 가질 수 있습니다.

7. 테마가 사용 가능한 이모지보다 더 많은 카드 쌍을 표시하도록 잘못 지정한 경우, 사용 가능한 이모티콘 수와 일치하도록 자동으로 카드 수를 줄일 수 있어야 합니다.

8. 적어도 6개의 테마를 지원하세요.

9. 새로운 테마를 게임에 한 줄의 코드로 추가할 수 있어야 합니다.

10. 새로운 게임을 시작하는 "New Game" 버튼을 UI(어디든 좋다고 생각하는 위치에)에 추가하세요.

11. 새로운 게임은 랜덤 선택된 테마로 시작해야 합니다. 그리고 "New Game" 버튼을 터치할 때마다 새로운 랜덤 테마가 선택되어야 합니다.

12. 새로운 게임은 카드들이 모두 아래를 보게 뒤집힌 채로 시작되어야 합니다.

13. 새 게임의 카드는 완전히 섞인 상태여야 합니다. 카드의 이모지가 테마에서 선택되어(필수 구현 5번 처럼) 순서가 예측가능하지 않은 상태로 있어야 합니다. 그리고 카드의 쌍이 강의처럼 나란히 있어서는 안됩니다.

14. UI에 테마 이름을 표시합니다. 원하는 이름을 찾아서 표시하세요.

15. 카드를 확인할 때마다  짝이 맞지 않을 때마다  1점을 감점하고 짝이 맞을 경우 2점을 부여하세요. (이전에 확인한 여부와 상관 없이). 자세한 설명은 아래 Hints를 참고하세요. 사용자의 암기능력이 좋지 않을 경우 점수가 음수로 표시될 수도 있습니다.

16. 점수를 UI의 올바르다고 생각하는 위치에 표시하세요.

<br/><br/>

## Hints

1. 경제성은 여전히 (그리고 항상) 코딩에서 가치있습니다.

2. ViewModel이  Model에 연결된 부분은 하나의 "var model" 이상으로 구성될 수 있습니다. var은 몇 개도 될 수  있습니다. "Model"은 하나의 구조체가 아닌 개념적 독립체입니다.

3. (둘다 앱의 Model에 해당함에도 불구하고) 테마는 MemoryGame과 완전하게 분리되어 있습니다. 테마를 지원하기 위해서 "MemoryGame.swift" 파일을 한줄도 고치지 않아도 됩니다.

4. 테마는 이제 Model의 일부이기 때문에 UI와 독립적이어야 합니다. UI와 독립적으로 색을 표현하는 방법은 놀랍게도 미묘한 차이가 있습니다. (Swift 뿐만 아니라 일반적으로) 따라서 테마의 색상을 단순 문자열의 이름으로 나타내는 것이 좋습니다. "orange". 그 다음 ViewModel이 View에 대한 Model을 "해석"하는 가장 중요한 역할 중 하나를 하도록 합니다. View는 UI 종속 표현(ex, SwiftUI의 Color struct)을 통해  현재의 테마 색상에 접근할 수 있습니다.

5. 세앙의 모든 색상을 지원할 필요는 없습니다. (12개 정도면 충분합니다.) 하지만 "fuchsia"와 같이 ViewModel이 해석하는 방법을 모르는 색상이 Model에 포함되어 있다면 적절한 조치가 취해져야 합니다.
6. 우리는 나중에 UI 독립적인 방법으로 색상을 표현하는 (아직 완벽하지는 않지만) 더 나은 방법을 배울 것입니다.
7. 필수 과제 6이 의미하는 것은 예를 들어 할로윈 게임은 네 개의 🎃 카드를 가져서는 안됩니다.
8. 필수 과제 7이 의미하는 것은 예를 들어 테마의 이모지가  ["👻","🎃 ",“🕷"] 이고 테마에서 보여줄 카드의 짝이 47개일 경우, 자동적으로 보여줄 카드의 개수가 47개에서 3개로 줄어들어야 합니다.

9. 이 과제에서 Array의 randomElement()가 유용할 것입니다. (이 함수가 옵셔널을 반환한다는 것을 명심하고 대비하세요.) 반드시 사용해야 하는 것은 아니고 그저 힌트입니다.

10. 과제에서 필수적으로 사용해야 할 옵셔널은 없습니다. (이것이 좋은 방법이라면 그렇게 해도 됩니다.)

11. 새 Memory game을 생성하기 위해 강의의 static func createMemoryGame() 을 남겨두고 싶을 것입니다. 하지만 이 함수는 그 역할을 하기 위해 조금 더 많은 정보가 필요합니다. 그러니 확실히 매개변수를 추가해야 할 것입니다.

12. 반면에, 어떤 테마든 현재 태마에서 가져올 것이기 때문에 저번주의 static let emojis를 더 이상 사용하지 않을 것입니다.

13. 아마 ViewModel에 init()을 추가해야 할 것입니다. 왜냐하면 다른 변수에 선언이 영향을 받는 변수를 가지게 될 것이기 때문입니다.  init()에서 변수들이 초기화 되는 순서를 제어할 수 있기 때문에 init()에서 이러한 종류의 catch-22를 해결할 수 있습니다. (이것이 변수 생성자가 다른 변수를 참조할 수 없는 이유입니다.)

14. ViewModel의 init() 안의 코드는 새 게임 메커니즘과 관련된 코드와 아마 매우 유사해 보일 수 있습니다. 왜냐하면 이 두 곳에서 새 게임을 시작하고 싶어하기 때문입니다. 여기서 코드 중복이 발생하더라도 걱정하지 마세요. (이 코드를 뺄 수 있을 만큼 Swift에 대해서 많이 알고 있지 못할 겁니다.)

15. 아마 과제에서 두개의 다른 배열을 셔플해야 할 것입니다. 이것은 필수는 아니고 힌트입니다.

16. 스위프트에서 클로저라 불리는 "in-line 함수" 의 놀라운 점은 클로저 스코프 안에서 지역 변수를 선언하면 클로저는 그 변수를 사용할 수 있다는 것입니다! 예를 들어, 만약 아래의 foo 함수가  ()->void 함수를 매개변수로 가지면 ...
```
let grettings = ["Hello", "Howdy", "Heya"].shuffled()
foo {
	print(greetings) // 이것은 가능합니다! greetings가 여기서 사용가능해요!
}
```
이것은 필수과제 5를 위해 유용할 것입니다.

17. 모든 코드 구간에서 신중하게 생각하세요. (이게 View에 들어가야 하는지, ViewModel 혹은 Model에 들어가야 하는지) 이 과제는 거의 MVVM에 관한 것입니다. 그러니 이를 올바르게 적용하는 것은 중요합니다.

18. 아직 필수는 아니지만, private 키워드 혹은 private(set) 키워드를 적절하다고 생각되는 변수에 사용해보세요.

19. 카드는 앞면이 위로 향했다가 뒤집히는 경우에만 "이미 본 상태"입니다. 따라서 "확인한" 카드를 인식하고 있는 것은 앞면이 위를 향하도록 카드를 뒤집을 때 하면 됩니다.

20. 🐧 + 👻 을 뒤집고, ✏️ + 🏀 을 뒤집은 다음 두개의 👻 을 뒤집은 경우 점수는 2점이 될 것입니다. 왜냐하면 🐧, ✏️,, 🏀이  아직 mismatch되지 않았기 때문입니다. 만약에 🐧 + 🐼 를 뒤집고, 🏀 + 🐧 을 한번 더 뒤집는다면 3점이 떨어져서 -1점이 될 것입니다. 왜냐하면 🐧 카드는 이미 확인되었고, 🏀 또한 이미 확인되었기 때문입니다. 마지막으로 🐧 + 🐧 을 뒤집는다면 2점을 얻어서 총 1점이 될 것입니다.

21. 이미 봤다는 개념은 이모지를 봤다는 것이 아니라 해당하는 카드를 봤다는 것입니다.
